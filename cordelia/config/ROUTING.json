{
    "abij": {
        "input": "k",
        "core": "PARAM_1    init i(gkbeatf)\n\nPARAM_OUT absolute_dist PARAM_IN, PARAM_1",
        "opcode": "opcode absolute_dist, a, ak\n    ain, kp1 xin\n\nsetksmps 1\n\nafx     balance2 abs(ain), ain\namod\tabs lfo:a(1, kp1/2)\n\nafx\t*= (1-amod)\nain\t*= amod\n\naout\t= afx + ain\n\n    xout aout\n    endop"
    },
    "chebij": {
        "input": "k",
        "core": "PARAM_1    init 64\n\nPARAM_OUT cordelia_chebyshev PARAM_IN, PARAM_1",
        "opcode": "opcode cordelia_chebyshev, a, ak\n    ain, kfreq xin\n\nk0      jitter 1, gkbeatf/kfreq, gkbeatf/kfreq/2\nk1\t\tjitter 1, gkbeatf/kfreq, gkbeatf/kfreq/2\nk2\t\tjitter 1, gkbeatf/kfreq, gkbeatf/kfreq/2\nk3\t\tjitter 1, gkbeatf/kfreq, gkbeatf/kfreq/2\nk4\t\tjitter 1, gkbeatf/kfreq, gkbeatf/kfreq/2\nk5\t\tjitter 1, gkbeatf/kfreq, gkbeatf/kfreq/2\nk6\t\tjitter 1, gkbeatf/kfreq, gkbeatf/kfreq/2\n\naout        chebyshevpoly  ain, k0, k1, k2, k3, k4, k5, k6\naout        chebyshevpoly  aout, k6, k5, k4, k3, k2, k1, k0\n\naout        balance aout, ain\n\n    xout aout\n    endop"
    },
    "combij": {
        "input": "kkk",
        "core": ";krvt\t= ktime\n;klpt\t= kfb*(imaxlpt/1000)\n\nPARAM_1 init i(gkbeats)\nPARAM_2 init .5\nPARAM_3 init .5\n\nPARAM_OUT\tvcomb_balance PARAM_IN, PARAM_1, PARAM_2, PARAM_3",
        "opcode": "opcode vcomb_balance, a, akkk\n    ain, ktime, kfb, kmix xin\n\nimax_t\tinit 15\nacomb\tvcomb ain, ktime, kfb*(imax_t/1000), imax_t\n;acomb\tbalance2 acomb, ain\n\naout\t= ain*(1-kmix) + acomb*kmix\n\n    xout aout\n    endop"
    },
    "convij": {
        "input": "Skk",
        "core": "PARAM_2\tinit 1\nPARAM_3\tinit 1\n\nPARAM_OUT cordelia_cross PARAM_IN, PARAM_1, ich, PARAM_2, PARAM_3",
        "opcode": "opcode cordelia_cross, a, aSikk\n    ain, String, ich, kdyn, kmix xin\n\nadest\t    chnget sprintf(\"%s_%i\", String, ich)\n\nacross      cross2 ain*kdyn, adest, 4096, 2, gihanning, kmix\n\naout\t    = ain*(1-kmix) + across*kmix\n\n    xout aout\n    endop"
    },
    "convij2": {
        "input": "Sk",
        "core": "PARAM_2\tinit 1\n\nPARAM_OUT cordelia_cross1024 PARAM_IN, PARAM_1, ich, PARAM_2",
        "opcode": "opcode cordelia_cross1024, a, aSik\n    ain, String, ich, kmix xin\n\nadest\tchnget sprintf(\"%s_%i\", String, ich)\n\nacross      cross2 ain, adest, 1024, 2, gihanning, kmix\n;abalanced   balance2 across, ain\n\naout\t    = ain*(1-kmix) + across*kmix\n\n    xout aout\n    endop"
    },
    "convij8": {
        "input": "Sk",
        "core": "PARAM_2\tinit 1\n\nPARAM_OUT cordelia_cross8192 PARAM_IN, PARAM_1, ich, PARAM_2",
        "opcode": "opcode cordelia_cross8192, a, aSik\n    ain, String, ich, kmix xin\n\nadest\tchnget sprintf(\"%s_%i\", String, ich)\n\nacross      cross2 ain, adest, 8192, 4, gihanning, kmix\n;abalanced   balance2 across, ain\n\naout\t    = ain*(1-kmix) + across*kmix\n\n    xout aout\n    endop"
    },
    "crispij": {
        "input": "kk",
        "core": "PARAM_1    init 3\nPARAM_2    init 3\n\nPARAM_OUT cordelia_crispy PARAM_IN, PARAM_1, PARAM_2",
        "opcode": "opcode cordelia_crispy, a, akk\n    ain, kratio_l, kratio_h xin\n\nidt                 init ksmps / sr\n\nalow, ahigh, aband  svfilter  ain, ntof(\"2B\"), .75\narms_low            follow alow, idt\nkrms_low            k arms_low\nalpf\t\t        K35_lpf ain, ntof(\"2B\"), 5+krms_low, 1.25, 1+krms_low*kratio_l\n\narms_high           follow ahigh, idt\nkrms_high           k arms_high\nahpf\t\t        K35_hpf ain, ntof(\"2B\"), 5+krms_high*2, 1.125, 1+krms_high*kratio_h\n\n\nk0\t\tinit -.75\nk1\t\tinit .45\nk2\t\tinit .125\nk3\t\tinit -1/12\nk4\t\tinit .645\nk5\t\tinit -.245\nk6\t\tinit .025\nk7\t\tinit -.87535\n\n;=======================================================================\n;let's add a delay on the high\nahpf_delx\t\t\tinit 0\nkfreq_samphold      = 1.5+krms_high*35\n\nkdel_t\t\tsamphold gkbeats/3, metro(kfreq_samphold)\n/* kdel_t\t\t\tinit 0\nif kdel_t_temp > 1/12 then\n\tkdel_t = kdel_t_temp\nendif */\nkfeedback \t= .15 + oscil3(.75+jitter(.05, 1, 3), kfreq_samphold, giasquare)\n\nahpf_delx\t\tvdelayx ahpf+ahpf_delx*(1-kfeedback), a(kdel_t), 5, 4096\n;=======================================================================\n        \n\nacheby\t\tchebyshevpoly  (alpf/kratio_l+ahpf/kratio_h+(ahpf_delx/(kratio_h*3)))/4, k0, k1, k2, k3, k4, k5, k6, k7\naout        = ain/(kratio_l+kratio_h)+acheby*linsegr(0, .95, 1, 1, 0)*(kratio_l+kratio_h)/8\n\n    xout aout\n    endop"
    },
    "cutij": {
        "input": "kk",
        "core": "PARAM_1\t\tinit 8\nPARAM_2\t\tinit .5\n\nPARAM_OUT\tjohanner_cut PARAM_IN, PARAM_1, 1, PARAM_2",
        "opcode": "/*\n\tArgs:  \n\t* asig : input signal\n\t* imaxdur : size of buffer in seconds\n\t* ksub : slicing subdivision\n\t* kchoice : which subdivision to use (not obvious it is useful)\n\t* kstutter : 1 for stutter, 0 for normal\n\t* kstutterspeed : speedy gonzales\n\n*/\n\nopcode johanner_cut, a, akkk\n    ; Inputs: audio signal, number of slices, selected slice, wet mix\n    asig, ksub, kchoice, kwet xin\n\n    ;------------------------------------------------------------\n    ; INITIAL SETUP\n    ;------------------------------------------------------------\n\n    imaxdur init 1\n    imaxdur = imaxdur * 4\n    if imaxdur < 0.5 then\n        imaxdur = 4\n    endif\n\n    ; Trigger for change detection\n    ktrig metro 5\n    kstutter init 0\n    kstutterspeed init int(random(1, 3))\n\n    ; Ensure selected slice is within bounds\n    kchoice = kchoice % ksub\n\n    ; Change detection flags\n    ksub_ch init 0\n    kchoice_ch init 0\n    kstutter_ch init 0\n\n    if changed2(ktrig) == 1 then\n        ksub_ch = changed2(ksub)\n        kchoice_ch = changed2(kchoice)\n        kstutter_ch = changed2(kstutter)\n    endif\n\n    ;------------------------------------------------------------\n    ; BUFFER INITIALIZATION\n    ;------------------------------------------------------------\n\n    ilen_smps = imaxdur * sr\n    ibuf ftgentmp 0, 0, ilen_smps, -2, 0\n    ibuf_stutter ftgentmp 0, 0, ilen_smps, -2, 0\n\n    ; For stutter\n    kstut_sub init 1\n    kstut_rpos init 0\n    if kstutter_ch > 0 then\n        kstut_sub = ksub\n        kstut_rpos = 0\n    endif\n    kstut_limit = int(ilen_smps / kstut_sub)\n\n    ;------------------------------------------------------------\n    ; WRITE INPUT AUDIO TO MAIN BUFFER\n    ;------------------------------------------------------------\n\n    kwrite_ptr init 0\n    kcnt = 0\n    while kcnt < ksmps do\n        tablew(asig[kcnt], kwrite_ptr, ibuf)\n        kwrite_ptr = (kwrite_ptr + 1) % ilen_smps\n        kcnt += 1\n    od\n\n    ;------------------------------------------------------------\n    ; READ FROM SLICE OR STUTTER BUFFER\n    ;------------------------------------------------------------\n\n    kincr init 0\n    kinit init 1\n    kreach init 0\n\tkonset init 0\n    if kinit == 1 || kchoice_ch > 0 || ksub_ch > 0 then\n        kplus = ilen_smps / ksub * kchoice\n        kread_ptr = (kwrite_ptr + kplus) % ilen_smps\n        kincr = 0\n    endif\n\n    kinit = 0\n\n    ; STUTTER BRANCH\n    if kstutter > 0 kgoto stutter\n\n    ;------------------------------------------------------------\n    ; NORMAL SLICE READING\n    ;------------------------------------------------------------\n\n    kcnt = 0\n    while kcnt < ksmps do\n        aout[kcnt] = table((kread_ptr + kincr + konset) % ilen_smps, ibuf)\n        kincr = (kincr + 1) % int(ilen_smps / ksub)\n        tablew(aout[kcnt], kincr, ibuf_stutter)\n        if kincr == 0 then\n            kreach = 1\n\t\t\tkonset += random(0, 8)\n\t\t\tif konset >= 128 then\n\t\t\t\tkonset = 0\n\t\t\tendif\n\t\t\tprintk2 konset\n        endif\n        kcnt += 1\n    od\n\n    kgoto mix\n\n    ;------------------------------------------------------------\n    ; STUTTER READING\n    ;------------------------------------------------------------\n\nstutter:\n    kcnt = 0\n\n    while kcnt < ksmps do\n        aout[kcnt] = table(kstut_rpos, ibuf_stutter)\n        kstut_rpos = (kstut_rpos + kstutterspeed) % kstut_limit\n        kcnt += 1\n    od\n\n    ;------------------------------------------------------------\n    ; MIX INPUT AND PROCESSED SIGNAL\n    ;------------------------------------------------------------\n\nmix:\n    amix = asig * (1 - kwet) + aout * kwet\n    xout amix\n\nendop"
    },
    "cutij2": {
        "input": "kk",
        "core": "PARAM_1\t\tinit 8\nPARAM_2\t\tinit .5\n\nPARAM_OUT\tjcut PARAM_IN, PARAM_1, 1, PARAM_2",
        "opcode": "/*\n\tArgs:  \n\t* asig : input signal\n\t* imaxdur : size of buffer in seconds\n\t* ksub : slicing subdivision\n\t* kchoice : which subdivision to use (not obvious it is useful)\n\t* kstutter : 1 for stutter, 0 for normal\n\t* kstutterspeed : speedy gonzales\n\n*/\n\nopcode jcut, a, akkk\n\tasig, ksub, kchoice, kwet xin\n\n\timaxdur init i(gkbeats)\n\timaxdur init imaxdur*4\n\tif imaxdur < .5 then\n\t\timaxdur = 4\n\tendif\n\tkstutter init 0\n\tktrig init i(gkbeatn)\n\tktrig = gkbeatn\n\n\tkkey, kdown sensekey\n\tif gkkeyboard_spacebar == 1 then \n\t\tkstutter = (kstutter + 1 ) % 2\n\t\tkstutterspeed = int(random:k(1, 3))\n\tendif\n\n\tkchoice = kchoice % ksub\n\tkreach init 0\n\n\tif changed2(ktrig) == 1 then\n\t\tksub_ch = changed2(ksub)\n\t\tkchoice_ch = changed2(kchoice)\n\t\tkstutter_ch = changed2(kstutter)\n\tendif\n\t\n\tilen_smps = imaxdur * sr\n\tibuf ftgentmp 0, 0, ilen_smps, -2, 0\n\t\n\tkstut_sub init 1\n\tkstut_rpos init 0\n\tif(kstutter_ch > 0) then \n\t\tkstut_sub = ksub\n\t\tkstut_rpos = 0\n\tendif\n\n\tkstut_limit = int(ilen_smps / kstut_sub)\n\tibuf_stutter ftgentmp 0, 0, ilen_smps, -2, 0\n\n\tkwrite_ptr init 0\n\t\n\tasig init 0\n\n\tkcnt = 0\n\twhile kcnt < ksmps do \n\t\ttablew(asig[kcnt], kwrite_ptr, ibuf)\n\t\tkwrite_ptr = (kwrite_ptr + 1) % ilen_smps\n\t\tkcnt += 1\n\tod\n\n\tkincr init 0\n\tkinit init 1\n\tif(kinit == 1  || kchoice_ch > 0 || ksub_ch > 0 ) then\n\t\tkplus = ilen_smps / ksub * kchoice\n\t\tkread_ptr = (kwrite_ptr + kplus) % ilen_smps\n\t\tkincr = 0\n\tendif\n\tkreach = 0\n\n\tkcnt = 0\n\tif(kstutter > 0) kgoto stutter\n\n\tkinit = 0\n\twhile kcnt < ksmps do \n\t\taout[kcnt] = table(  (kread_ptr + kincr) % ilen_smps, ibuf)\t\n\t\tkincr = (kincr + 1) % int(ilen_smps / ksub) \n\t\t// Write for stutter\n\t\ttablew(aout[kcnt], kincr, ibuf_stutter)\n\t\tif(kincr == 0) then \n\t\t\tkreach = 1\n\t\tendif\n\t\tkcnt += 1 \n\tod\n\tkgoto nostutter\n\n\tstutter:\n\tkcnt = 0\n\twhile kcnt < ksmps do \n\t\taout[kcnt] = table(kstut_rpos, ibuf_stutter)\n\t\tkstut_rpos = (kstut_rpos + kstutterspeed) % int(ilen_smps / kstut_sub)\n\t\tkcnt += 1\t\t\n\tod\n\n\tnostutter:\n\namain_out\t= asig*(1-kwet) + aout*kwet\n\n\txout amain_out\nendop"
    },
    "dc": {
        "input": "kk",
        "core": "PARAM_OUT cordelia_dc PARAM_IN",
        "opcode": "opcode cordelia_dc, a, a\n    ain xin\n\naout    dcblock2 ain\n\n    xout aout\n    endop"
    },
    "decij": {
        "input": "kk",
        "core": "PARAM_1    init 16\nPARAM_2    init sr\n\nPARAM_OUT cordelia_decimator PARAM_IN, PARAM_1, PARAM_2",
        "opcode": "opcode cordelia_decimator, a, akk\t;UDO Sample rate / Bit depth reducer\n\n\tsetksmps   1\n\n\tain, kbit, ksrate xin\n\nkbits\t\t=        2^kbit                ;bit depth (1 to 16)\nkfold\t\t=        (sr/ksrate)           ;sample rate\nkin\t\t\tdownsamp ain                   ;convert to kr\nkin\t\t\t=        (kin+0dbfs)           ;add DC to avoid (-)\nkin\t\t\t=        kin*(kbits/(0dbfs*2)) ;scale signal level\nkin\t\t\t=        int(kin)              ;quantise\naout\t\tupsamp   kin                   ;convert to sr\naout\t\t=        aout*(2/kbits)-0dbfs  ;rescale and remove DC\na0ut\t\tfold     aout, kfold           ;resample\n\t\t\txout     a0ut\n\n\tendop"
    },
    "delij": {
        "input": "kk",
        "core": "PARAM_1 init i(gkbeats)\nPARAM_2\tinit .5\n\nPARAM_OUT    cordelia_delay_array PARAM_IN, PARAM_1, PARAM_2, 4",
        "opcode": "opcode cordelia_delay_array, a, akki\n    setksmps 1\n    adel_in, kdel_time, kfb, instances xin\n\nadel_in     init 0\nadel_tap    init 0\n\nidel_buf    init 10\n\nadel_dump   delayr idel_buf\nadel_tap    deltap kdel_time\n            delayw adel_in + (adel_tap * kfb)\n\nadel_out    = adel_tap;, -1, 1\n\nif instances > 1 then\n    adel_out += cordelia_delay_array(adel_out, random:i(-1/12, 1/12) + kdel_time + .15*instances, kfb/instances, instances-1)/4\nendif\n\n    \n    xout adel_out\n    \n    endop"
    },
    "delij2": {
        "input": "kkk",
        "core": "PARAM_1 init i(gkbeats)\nPARAM_2\tinit .5\nPARAM_3 init .5\n\nPARAM_OUT    cordelia_delay PARAM_IN, PARAM_1, PARAM_2, PARAM_3",
        "opcode": "opcode cordelia_delay, a, akkk\n    ain, ktime, kfb, kwet xin\n\n    adel init 0\n    adel vdelayx    kwet*(ain+adel*kfb),    a(samphold:k(ktime, changed2:k(gkbeatn))),           10,         4096\n    \n    aout = ain*(1-kwet) + adel\n\n    xout aout\nendop"
    },
    "dio": {
        "input": "kk",
        "core": "PARAM_1    init ntof(\"4B\")\nPARAM_2    init .5\n\nPARAM_OUT cordelia_diode_ladder PARAM_IN, PARAM_1, PARAM_2",
        "opcode": "opcode cordelia_diode_ladder, a, akk\n    ain, kfreq, kq xin\n\nkfreq_var   = (kfreq*11/10)-kfreq\nkfreq       = kfreq + jitter(1, gkbeatf/8, gkbeatf)*kfreq_var\n\n; safe limit\nkfreq       limit kfreq, 20, 17.5$k\n\n; core\nisaturation init 1.25\ninlp        init 1\naout        diode_ladder ain, kfreq, kq*17, inlp, isaturation\n\nkdyn_comp   pow (kfreq / giNYQUIST), -0.15\naout        *= kdyn_comp\n;aout\t    balance2 aout, ain\n\n    xout aout\n    endop"
    },
    "duij": {
        "input": "Sk",
        "core": "PARAM_2\tinit 1\n\nPARAM_OUT    cordelia_duck PARAM_IN, PARAM_1, ich, PARAM_2",
        "opcode": "gkcordelia_duck_atk init 5$ms\ngkcordelia_duck_rel init 75$ms\n\n    opcode cordelia_duck, a, aSik\n    ain, Sinstr, ich, kmix xin\n\naenv    follow2 chnget:a(sprintf(\"%s_%i\", Sinstr, ich)), gkcordelia_duck_atk, gkcordelia_duck_rel\nafol\t= ain * (1-aenv)\n\naout\t= afol*kmix + ain*(1-kmix)\n\n    xout aout\n    endop"
    },
    "dustij": {
        "input": "k",
        "core": "PARAM_1 init .5\n\nPARAM_OUT cordelia_reverb_dust PARAM_IN, PARAM_1",
        "opcode": "opcode cordelia_reverb_dust, a, ak\n\tain, kwet xin\n\n\t\tkwet limit kwet, 0, 1\n\n\t\timaxdur init i(gkbeats)\n\t\timaxdur init imaxdur*8\n\n\t\twhile imaxdur < .5 do\n\t\t\timaxdur *= 2\n\t\tod\n\n\t\tarev\tinit 0\n\t\taenv_delay\tinit 0\n\n\t\taenv_pre\tfollow ain, (ksmps/sr)*8\n\t\taenv_delay\tvdelay3 aenv_pre+aenv_delay*(.75+jitter(.25, 1/32, 1/3)), 1/$M_PI, imaxdur\n\t\t\t\t\t\n\t\taenv sum aenv_pre, aenv_delay\n\n\t\tadust\tdust2 1, gkbeatf*256*k(aenv)\n\t\ta_, a_, aband svfilter adust, randomh:k(6500, 11500, gkbeatf+gkbeatf*k(aenv_delay)), 5\n\n\t\t;asum\t= ain * aband/2\n\t\taconv\tcross2 ain, aband, 1024, 2, gihanning, 1\n\t\taconv\t*= 3\n\n\t\taout =  ain*(1-kwet) + aconv*kwet;*(1-kfb/4)\n\n\txout aout\nendop"
    },
    "flanij": {
        "input": "kkk",
        "core": "PARAM_1\t\tinit i(gkbeats)\nPARAM_2\t\tinit .5\nPARAM_3\t\tinit .5\n\nPARAM_OUT\tcordelia_flanger PARAM_IN, PARAM_1, PARAM_2, PARAM_3",
        "opcode": "opcode cordelia_flanger, a, akkk\n    ain, ktime, kfb, kwet xin\n\n; imax_delay(optional) -- maximum delay in seconds (needed for inital memory allocation)\nimax_delay init 5\n\n\nadel        flanger ain*kwet, a(ktime), kfb, imax_delay\n\naout         =  ain*(1-kwet) + adel ; kwet is already in the delay\n\n    xout aout\n    endop"
    },
    "flanijp": {
        "input": "kk",
        "core": "PARAM_1\t\tinit i(gkbeats)\nPARAM_2\t\tinit .5\n\nPARAM_OUT\tcordelia_flanger_port PARAM_IN, PARAM_1, PARAM_2",
        "opcode": "opcode cordelia_flanger_port, a, akk\n    ain, ktime, kfb xin\n\naout       flanger ain, a(portk(ktime, gkbeats/24)), portk(kfb, .025), 15\n\n    xout aout\n    endop"
    },
    "flij": {
        "input": "kkk",
        "core": "PARAM_1\t\tinit i(gkbeats)\nPARAM_2\t\tinit .5\nPARAM_3     init .5\n\nPARAM_OUT\tcordelia_flanger_mix PARAM_IN, PARAM_1, PARAM_2, PARAM_3",
        "opcode": "opcode cordelia_flanger_mix, a, akkk\n    ain, ktime, kfb, kmix xin\n\nadel       flanger ain, a(ktime), kfb, 15\naout\t    = ain*(1-kmix) + adel*kmix\n\n    xout aout\n    endop"
    },
    "folij": {
        "input": "Sk",
        "core": "PARAM_2 init 1\n\nPARAM_OUT cordelia_follow PARAM_IN, PARAM_1, PARAM_2, ich",
        "opcode": "opcode cordelia_follow, a, aSki\n    ;setksmps 1\n    ain, String, kwet, ich xin\n\naduck\t    chnget sprintf(\"%s_%i\", String, ich)\n\n/* adest       *= .75\t\t;reduce volume a bit\nadest       tone    adest, 500     ;smooth estimated envelope\n;adest       moogladder2 adest, 500, .95\n;aenv        follow2 adest, .005, .01\naenv        follow adest, .005;, .01\naout        balance ain, aenv */\n\nkthresh     init 0\nklo_knee    init 48\nkhi_knee    init 60\nkratio      init 5.5\nkatk        init .015\nkrel        init .05\nilookahead  init 50/1000\n\naout        compress ain, aduck, kthresh, klo_knee, khi_knee, kratio, katk, krel, ilookahead\n;aout        *= 6-follow2(aduck, .005, gkbeats/4)\naout        = ain*(1-kwet) + aout*kwet\n    xout aout\n    endop"
    },
    "folij2": {
        "input": "Sk",
        "core": "PARAM_2 init 1\n\nPARAM_OUT cordelia_follow2 PARAM_IN, PARAM_1, PARAM_2, ich",
        "opcode": "opcode cordelia_follow2, a, aSki\n    ;setksmps 1\n    ain, String, kwet, ich xin\n\nadest\t    chnget sprintf(\"%s_%i\", String, ich)\n\nadest       *= .75\t\t;reduce volume a bit\nadest       tone    adest, 1500     ;smooth estimated envelope\n;adest       moogladder2 adest, 500, .95\n;aenv        follow2 adest, .005, .01\naenv        follow adest, .005;, .01\naout        = ain*(1-aenv)\n\naout        = ain*(1-kwet) + aout*kwet\n\n    xout aout\n    endop"
    },
    "folij3": {
        "input": "Sk",
        "core": "PARAM_2 init 1\n\nPARAM_OUT cordelia_follow3 PARAM_IN, PARAM_1, PARAM_2, ich",
        "opcode": "opcode cordelia_follow3, a, aSki\n    ;setksmps 1\n    ain, String, kwet, ich xin\n\naduck\t    chnget sprintf(\"%s_%i\", String, ich)\n\naout        = ain*(1-follow2(aduck, .005, gkbeats/4))\naout        = ain*(1-kwet) + aout*kwet\n    xout aout\n    endop"
    },
    "folijd": {
        "input": "Sk",
        "core": "PARAM_2 init 1\n\nPARAM_OUT cordelia_follow_drum PARAM_IN, PARAM_1, PARAM_2, ich",
        "opcode": "opcode cordelia_follow_drum, a, aSki\n    ;setksmps 1\n    ain, String, kwet, ich xin\n\naduck\t    chnget sprintf(\"%s_%i\", String, ich)\naduck       moogladder2 aduck, 195, .5\n\nif rms(aduck) > .5 && metro:k(60) ==  1 then\n    ktrig = 1\nelse\n    ktrig = 0\nendif\n\naout         = ain*triglinseg:a(ktrig, 1, .005, 0, .095, 1)\n;aout        *= 6-follow2(aduck, .005, gkbeats/4)\naout        = ain*(1-kwet) + aout*kwet\n    xout aout\n    endop"
    },
    "getmeout": {
        "input": "k",
        "core": "PARAM_1\t\tinit 1\n\nPARAM_OUT\t= PARAM_IN*portk(PARAM_1, .005)",
        "opcode": null
    },
    "glass": {
        "input": "kk",
        "core": "PARAM_1    init 500\nPARAM_2    init .5\n\nPARAM_OUT cordelia_glass PARAM_IN, PARAM_1, PARAM_2",
        "opcode": "#define cordelia_glass_cps(main_freq) #$main_freq+(cent(25)*jitter:k(1, gkbeatf/8, gkbeatf))#\n#define cordelia_glass_q(main_freq) #$main_freq+jitter:k(1, gkbeatf/8, gkbeatf)#\n\n    opcode cordelia_glass, a, akk\n    ain, kfreq, kq xin\n\nif1     init 80\nif2     init 188\n\niq1     init 8\niq2     init 3\n\naexc1    mode ain, $cordelia_glass_cps(if1), $cordelia_glass_q(iq1)\naexc2    mode ain, $cordelia_glass_cps(if2), $cordelia_glass_q(iq2)\n\naexc    = (aexc1+aexc2)/2\naexc    limit aexc, 0, 1\n\nares1   mode aexc,  $cordelia_glass_cps(kfreq),  $cordelia_glass_q(scale(kq, 500, 60))\nares2   mode aexc,  $cordelia_glass_cps(kfreq*2),  $cordelia_glass_q(scale(kq, 420, 53))\n\naout    = (ares1+ares2)/2\n\naout    balance2 aout, ain\nadel    flanger aout, a(1/$cordelia_glass_cps), kq/12\n\naout    = aout + adel/8\n\n    xout aout\n    endop"
    },
    "guitar": {
        "input": "kk",
        "core": "PARAM_1    init 500\nPARAM_2    init .5\n\nPARAM_OUT cordelia_guitar PARAM_IN, PARAM_1, PARAM_2",
        "opcode": "#define cordelia_guitar_cps(main_freq) #$main_freq+(cent(25)*jitter:k(1, gkbeatf/24, gkbeatf/8))#\n#define cordelia_guitar_bw(bw) #$bw+jitter:k(1, gkbeatf/24, gkbeatf/8)#\n\n    opcode cordelia_guitar, a, akk\n    ain, kfreq, kq xin\n\na1    resonz ain, $cordelia_guitar_cps(ntof(\"2E\")), $cordelia_guitar_bw(10)\na2    resonz ain, $cordelia_guitar_cps(ntof(\"2B\")), $cordelia_guitar_bw(10)\na3    resonz ain, $cordelia_guitar_cps(ntof(\"2G\")), $cordelia_guitar_bw(10)\na4    resonz ain, $cordelia_guitar_cps(ntof(\"3D\")), $cordelia_guitar_bw(10)\na5    resonz ain, $cordelia_guitar_cps(ntof(\"3A\")), $cordelia_guitar_bw(10)\na6    resonz ain, $cordelia_guitar_cps(ntof(\"3E\")), $cordelia_guitar_bw(10)\n\naout    sum a1, a2, a3, a4, a5, a6\naout    balance aout, ain\n    xout (ain+aout+reverb(aout, .25))/2\n    endop"
    },
    "irpno": {
        "input": "ki",
        "core": "PARAM_1    init .5\nPARAM_2    init 4096\n\nPARAM_OUT cordelia_piano_ir PARAM_IN, PARAM_1, PARAM_2",
        "opcode": "gScordelia_piano_irs[]      fillarray \"/Users/j/Documents/RESEARCH/IR-SYNTHESIS/piano-body-harmonic-ch1.wav\",  \"/Users/j/Documents/RESEARCH/IR-SYNTHESIS/piano-body-harmonic-ch2.wav\"\ngicordelia_piano_irs_len    lenarray gScordelia_piano_irs\n\n    opcode cordelia_piano_ir, a, aki\n    ain, kwet, ipartitionsize xin\n\nidel            init (ksmps < ipartitionsize ? ipartitionsize + ksmps : ipartitionsize)/sr   ; latency of pconvolve opcode\n\nkcount  init    idel*kr\n\n; SELECT THE FILE BASED ON CHANNELs\nich init 0\nuntil ich > ginchnls do\n    Sir = gScordelia_piano_irs[ich%gicordelia_piano_irs_len]\n    prints Sir\n    ich += 1\nod\n\n; since we are using a soundin [instead of in] we can do a kind of \"look ahead\"\n; without output, creating zero-latency  by looping during one k-pass\nloop:\n    aconv \tpconvolve kwet*ain/48, Sir, ipartitionsize\n\n    ain\t\tdelay  (1-kwet)*ain, idel  ; Delay dry signal, to align it with\n\n    kcount = kcount - 1\n if kcount > 0 kgoto loop\n    aout =  ain + aconv\n\n\n    xout aout\n    endop"
    },
    "irvln": {
        "input": "ki",
        "core": "PARAM_1    init .5\nPARAM_2    init 4096\n\nPARAM_OUT cordelia_piano_ir PARAM_IN, PARAM_1, PARAM_2",
        "opcode": "gScordelia_piano_irs[]      fillarray \"/Users/j/Documents/RESEARCH/IR-SYNTHESIS/best-violin/violin-body-ir-ch1.wav\", \"/Users/j/Documents/RESEARCH/IR-SYNTHESIS/best-violin/violin-body-ir-ch2.wav\"\ngicordelia_piano_irs_len    lenarray gScordelia_piano_irs\n\n    opcode cordelia_piano_ir, a, aki\n    ain, kwet, ipartitionsize xin\n\nidel            init (ksmps < ipartitionsize ? ipartitionsize + ksmps : ipartitionsize)/sr   ; latency of pconvolve opcode\n\nkcount  init    idel*kr\n\n; SELECT THE FILE BASED ON CHANNELs\nich init 0\nuntil ich > ginchnls do\n    Sir = gScordelia_piano_irs[ich%gicordelia_piano_irs_len]\n    prints Sir\n    ich += 1\nod\n\n; since we are using a soundin [instead of in] we can do a kind of \"look ahead\"\n; without output, creating zero-latency  by looping during one k-pass\nloop:\n    aconv \tpconvolve kwet*ain/48, Sir, ipartitionsize\n\n    ain\t\tdelay  (1-kwet)*ain, idel  ; Delay dry signal, to align it with\n\n    kcount = kcount - 1\n if kcount > 0 kgoto loop\n    aout =  ain + aconv\n\n\n    xout aout\n    endop"
    },
    "megadistij": {
        "input": "kk",
        "core": "PARAM_1    init 16\nPARAM_2    init sr\n\nPARAM_OUT cordelia_mega_dist PARAM_IN, PARAM_1, PARAM_2",
        "opcode": "opcode cordelia_mega_dist, a, akk\t;UDO Sample rate / Bit depth reducer\n\tain, kbit, ksrate xin\n\nacheby\t\tchebyshevpoly  ain, random:i(0, 1), random:i(0, 1), random:i(0, 1), random:i(0, 1), random:i(0, 1), random:i(0, 1), random:i(0, 1), random:i(0, 1)\napoly\t\tpolynomial acheby, floor(random:i(0, 2)), floor(random:i(0, 2)), floor(random:i(0, 2)), floor(random:i(0, 2)), floor(random:i(0, 2)), floor(random:i(0, 2)), floor(random:i(0, 2)), floor(random:i(0, 2)), floor(random:i(0, 2)), floor(random:i(0, 2)), floor(random:i(0, 2)), floor(random:i(0, 2))\naout\t\t= apoly\n\t\t\txout     a0ut\n\n\tendop"
    },
    "moij": {
        "input": "kk",
        "core": "PARAM_1    init ntof(\"4B\")\nPARAM_2    init .5\n\nPARAM_OUT cordelia_moogladder2 PARAM_IN, PARAM_1, PARAM_2",
        "opcode": "opcode cordelia_moogladder2, a, akk\n    ain, kfreq, kq xin\n\nkfreq_var   = (kfreq*11/10)-kfreq\nkfreq       = kfreq + jitter(1, gkbeatf/8, gkbeatf)*kfreq_var\n\n; safe limit\nkfreq       limit kfreq, 20, 17.5$k\n\n; core\naout        moogladder2 ain, kfreq, kq\n\nkdyn_comp   pow (kfreq / giNYQUIST), -0.15\naout        *= kdyn_comp\n;aout\t    balance2 aout, ain\n\n    xout aout\n    endop"
    },
    "moij_old": {
        "input": "kk",
        "core": "PARAM_1    init ntof(\"4B\")\nPARAM_2    init .5\n\nPARAM_OUT cordelia_moogladder2_old PARAM_IN, PARAM_1, PARAM_2",
        "opcode": "opcode cordelia_moogladder2_old, a, akk\n    ain, kfreq, kq xin\n\nkfreq_var   = (kfreq*11/10)-kfreq\nkfreq       = kfreq + jitter(1, gkbeatf/8, gkbeatf)*kfreq_var\nkfreq       limit kfreq, 20, 20$k\naout        moogladder2 ain, kfreq, kq\naout\t    balance2 aout, ain\n\n    xout aout\n    endop"
    },
    "moijb3": {
        "input": "kk",
        "core": "PARAM_1    init 500\nPARAM_2    init .5\n\nPARAM_OUT cordelia_moijb3 PARAM_IN, PARAM_1, PARAM_2",
        "opcode": "gkcordelia_moijb3_port init 5$ms\ngkcordelia_moijb3_freq1 init 3\ngkcordelia_moijb3_freq2 init 4\ngkcordelia_moijb3_freq3 init 5\n\n    opcode cordelia_moijb3, a, akk\n    ain, kfreq, kq xin\n\nifreq_var\tinit 5\n\nkfreq1  limit kfreq + jitter:k(ifreq_var, gkbeatf/8, gkbeatf), 20, 20$k\na1      moogladder2 ain, portk(kfreq1, gkcordelia_moijb3_port), kq\n\na0      init 0\nkfreq2  limit gkcordelia_moijb3_freq1*kfreq + jitter:k(ifreq_var, gkbeatf/8, gkbeatf), 20, 20$k\na2      spf a0, a0, ain, portk(kfreq2, gkcordelia_moijb3_port), 2-(kq*2)\n\nkfreq3  limit gkcordelia_moijb3_freq2*kfreq + jitter:k(ifreq_var, gkbeatf/8, gkbeatf), 20, 20$k\na3      spf a0, a0, ain, portk(kfreq3, gkcordelia_moijb3_port), 2-(kq*2)\n\nkfreq4  limit gkcordelia_moijb3_freq3*kfreq + jitter:k(ifreq_var, gkbeatf/8, gkbeatf), 20, 20$k\na4      spf a0, a0, ain, portk(kfreq4, gkcordelia_moijb3_port), 2-(kq*2)\n\naout    = a1 + a2 + a3 + a4\n\naout\tbalance2 aout, ain\n\n    xout aout\n    endop"
    },
    "moijp": {
        "input": "kk",
        "core": "PARAM_1    init 500\nPARAM_2    init .5\n\nPARAM_OUT cordelia_moogladder2_port PARAM_IN, PARAM_1, PARAM_2",
        "opcode": "opcode cordelia_moogladder2_port, a, akk\n    ain, kfreq, kq xin\n\nkfreq_var   = (kfreq*11/10)-kfreq\naout        moogladder2 ain, portk(kfreq, gkbeats/12)+jitter(1, gkbeatf/8, gkbeatf)*kfreq_var, kq\naout\t    balance2 aout, ain\n\n    xout aout\n    endop"
    },
    "monster": {
        "input": "k",
        "core": "/*\na variation of decimator, i'm not very proud of it..\n*/\nPARAM_1    init 16\n\nPARAM_OUT cordelia_monster PARAM_IN, PARAM_1",
        "opcode": "opcode cordelia_monster, a, ak\t;UDO Sample rate / Bit depth reducer\n\n\tsetksmps   1\n\n\tain, kbit xin\n\nkbits\t\t=        2^kbit                ;bit depth (1 to 16)\nkin\t\t\tdownsamp ain                   ;convert to kr\n\n;kin\t\t\tabs kin ; cut low dynamic\nkin\t\t\ttan kin\nkin\t\t\t= 1 / (1 + sin(-kin))\n\nkin\t\t\t= (kin+0dbfs)           ;add DC to avoid (-)\nkin\t\t\t= kin*(kbits/(0dbfs*2)) ;scale signal level\nkin\t\t\t= ceil(kin)     ;quantise\n;kin\t\t\t= cos(kin * $M_PI)\n\naout\t\tupsamp   kin                   ;convert to sr\naout\t\t=        aout*(2/kbits)-0dbfs  ;rescale and remove DC\n\t\t\txout    aout / 12\n\n\tendop"
    },
    "notch": {
        "input": "kk",
        "core": "PARAM_1    init 35\nPARAM_2    init 0\n\nPARAM_OUT cordelia_notch PARAM_IN, PARAM_1, PARAM_2",
        "opcode": "opcode cordelia_notch, a, akk\n    ain, kratio, k_ xin\n\nkcps, krms pitchamdf ain, 35, 2500\n\nkfreq_samphold = 1.5+krms*kratio\n\n;===================\nkord \t\tinit 125\n;===================\n;kfeedback \tinit .95\nkfeedback \t= .15 + oscil3(.75+jitter(.05, 1, 3), kfreq_samphold/2, giasquare)\nanotch\t\tphaser1 ain, samphold:k(kcps, metro(kfreq_samphold)), kord, kfeedback\nanotch\t\t= (ain / 12 - anotch) / 2\n\nadelx\t\t\tinit 0\nkdel_t_temp\t\t= 1/samphold:k(kcps, metro(kfreq_samphold))*16\nkdel_t\t\t\tinit 0\nif kdel_t_temp > 1/12 then\n\tkdel_t = kdel_t_temp\nendif\n\nwhile kdel_t > 5 do\n\tkdel_t /= 2\nod\n\nadelx\t\tvdelayx anotch+adelx*(1-kfeedback), a(kdel_t), 5, 4096\n\nasum\t\tsum anotch, adelx / 8\n\naout\t\tbutterhp asum, 20\n\n    xout aout\n    endop"
    },
    "notch2": {
        "input": "kk",
        "core": "PARAM_1    init 35\nPARAM_2    init 0\n\nPARAM_OUT cordelia_notch PARAM_IN, PARAM_1, PARAM_2",
        "opcode": "opcode cordelia_notch, a, akk\n    ain, kratio, k_ xin\n\nkcps, krms pitchamdf ain, 35, 2500\n\nkfreq_samphold = 1.5+krms*kratio\n\n;===================\nkord \t\tinit 45\n;===================\n;kfeedback \tinit .95\nkfeedback \t= .15 + oscil3(.75+jitter(.05, 1, 3), kfreq_samphold/2, giasquare)\nanotch\t\tphaser1 ain, samphold:k(kcps, metro(kfreq_samphold)), kord, kfeedback\nanotch\t\t= (ain / 12 - anotch) / 2\n\nadelx\t\t\tinit 0\nkdel_t_temp\t\t= 1/samphold:k(kcps, metro(kfreq_samphold))*16\nkdel_t\t\t\tinit 0\nif kdel_t_temp > 1/12 then\n\tkdel_t = kdel_t_temp\nendif\n\nwhile kdel_t > 5 do\n\tkdel_t /= 2\nod\n\nadelx\t\tvdelayx anotch+adelx*(1-kfeedback), a(kdel_t), 5, 4096\n\nasum\t\tsum anotch, adelx / 8\n\naout\t\tbutterhp asum, 20\n\n    xout aout\n    endop"
    },
    "otij": {
        "input": "kkk",
        "core": "PARAM_1    init ntof(\"3B\")\nPARAM_2    init .35\nPARAM_3    init .5\n\nPARAM_OUT cordelia_OTT_comp PARAM_IN, PARAM_1, PARAM_2, PARAM_3",
        "opcode": "opcode cordelia_OTT_comp, a, akkk\n\tain, kfreq_high, kthresh, kwet xin\n\n\t;setksmps 512\n\nifreq_low\t\tinit 95\n\n;=== SPLIT INTO 3 BANDS ===;\nalow        \tbutlp ain, ifreq_low\napre_mid       \tbuthp ain, ifreq_low\namid        \tbutlp apre_mid, kfreq_high\nahigh       \tbuthp ain, kfreq_high\n\n;=== COMPRESSOR SETTINGS ===;\n\nkl_thresh   = kthresh * 3\nkm_thresh   = kthresh / 2\nkh_thresh   = kthresh * 2\n\nkup_ratio   = 3\nkdown_ratio = 9\n\n;\t=== ENVELOPES ===;\n\nkl_env\t\trms alow\nkm_env\t\trms amid\nkh_env\t\trms ahigh\n\n;      === LOW BAND GAIN ===;\nkl_gain     = (kl_env > kl_thresh) ? (kl_thresh + (kl_env - kl_thresh) / kdown_ratio) / kl_env \\\n\t\t\t\t\t\t\t\t   : (kl_env < kl_thresh) ? (kl_thresh - (kl_thresh - kl_env) / kup_ratio) / kl_env : 1\nalow_comp   = alow * kl_gain\n\n;\t=== MID BAND GAIN ===;\nkm_gain     = (km_env > km_thresh) ? (km_thresh + (km_env - km_thresh) / kdown_ratio) / km_env \\\n\t\t\t\t\t\t\t\t   : (km_env < km_thresh) ? (km_thresh - (km_thresh - km_env) / kup_ratio) / km_env : 1\namid_comp   = amid * km_gain\n\n;\t=== HIGH BAND GAIN ===;\nkh_gain     = (kh_env > kh_thresh) ? (kh_thresh + (kh_env - kh_thresh) / kdown_ratio) / kh_env \\\n\t\t\t\t\t\t\t\t   : (kh_env < kh_thresh) ? (kh_thresh - (kh_thresh - kh_env) / kup_ratio) / kh_env : 1\nahigh_comp  = ahigh * kh_gain\n\n;\t=== RECOMBINE BANDS ===\nacomp       = alow_comp + amid_comp + ahigh_comp\nacomp\t\t/= 12\n\n;   === DRY/WET MIX ===\naout        = (ain * (1 - kwet)) + (acomp * kwet)\n\n\txout aout\n\tendop"
    },
    "pconvij": {
        "input": "kk",
        "core": "PARAM_1\tinit 1\nPARAM_2\tinit 1\n\nPARAM_OUT    cordelia_pconvolve PARAM_IN, i(PARAM_1), PARAM_2, ich",
        "opcode": "opcode cordelia_pconvolve, a, aiki\n    ain, ir, kmix, ich xin\n\nSFiles[]        directory \"/Users/j/Documents/PROJECTs/CORDELIA/_setting/_IR\", \".wav\"\n\ninchnls         filenchnls SFiles[ir]\n;inchnls         init 2\n\nichnl_array     init (ich%inchnls)+1\n\naconv           pconvolve ain, SFiles[ir], 0, ichnl_array\n\naout            = aconv*kmix + ain*(1-kmix)\n\n    xout aout\n\n    endop"
    },
    "phij": {
        "input": "kkk",
        "core": "PARAM_1    init ntof(\"4B\")\nPARAM_2    init .5\nPARAM_3    init .5\n\nPARAM_OUT cordelia_moogladder2 PARAM_IN, PARAM_1, PARAM_2, PARAM_3",
        "opcode": "opcode cordelia_moogladder2, a, akkk\n    ain, kfreq, kfb, kwet xin\n\niord    init 18\nimode   init 1\nisep    init 1/$M_PI\n\naout    phaser2 ain, kfreq, .5+jitter(.25, 1/32, 1/3), iord, imode, isep, kfb\n\n\n    xout aout\n    endop"
    },
    "pitchebij": {
        "input": "kkkk",
        "core": "PARAM_1\t\tinit 0\nPARAM_2\t\tinit gibeats/48\nPARAM_3     init 1\nPARAM_4     init .25\n\nPARAM_OUT\tcordelia_pitch_chebyshev PARAM_IN, PARAM_1, PARAM_2, PARAM_3, PARAM_4",
        "opcode": "opcode cordelia_pitch_chebyshev, a, akkkk\n\tain, kdiv, kport, kratio, kwet xin\n\nilow\t\tinit 2\nihigh\t\tinit 15\nitime\t\tinit i(gkbeats)\nif itime <= 0 then\n\titime = 1/2\nendif\n\nidbthresh\tinit 3 ; dB threshold\nkoct, kdyn \tpitch ain, itime, ilow, ihigh, idbthresh\nkdyn\t\t= kdyn/pow(2, 16)\nif kdiv > 0 then\n\tkcycle\t\t= chnget:k(\"heart\") * divz(gkdiv, kdiv, 1)\n\tkoct\t\tsamphold koct, changed2(int(kcycle))\nendif\nkcps        = cpsoct(koct)\nkoct2\t\tvdel_k koct, gkbeats*kdiv, itime*2\nkcps2        = cpsoct(koct2)\n\nk1\t\t\tinit random(-1, 1)\nk2\t\t\tinit random(-1, 1)\nk3\t\t\tinit random(-1, 1)\nk4\t\t\tinit random(-1, 1)\nk5\t\t\tinit random(-1, 1)\n\naosc1\t\toscili 1, portk(kcps*kratio, kport)\nacheby1\t\tchebyshevpoly  aosc1, 0, k1, k2, k3, k4, k5\n\naosc2\t\toscili 1, portk(kcps2*kratio, kport)\nacheby2\t\tchebyshevpoly  aosc2, 0, k5, k4, k3, k2, k1\n\naosc\t\t= (acheby1 + acheby2/2)*portk(kdyn, kport/(1+jitter:k(.5, gkbeatf/8, gkbeatf)))\n;aosc\t\texciter aosc, kcps/2, kcps*9, 9, 3\n;aosc\t    dcblock2 aosc\n;aosc        balance2 aosc, ain\naosc2\t\tlimit aosc, -.95, .95\naout\t\t= ain*(1-kwet) + aosc*kwet\n\n\txout aout\n\tendop"
    },
    "pitchebijv": {
        "input": "kkk",
        "core": "PARAM_1\t\tinit 0\nPARAM_2\t\tinit gibeats/48\nPARAM_3     init .5\n\nPARAM_OUT\tcordelia_pitch_chebyshev_vco PARAM_IN, PARAM_1, PARAM_2, PARAM_3",
        "opcode": "opcode cordelia_pitch_chebyshev_vco, a, akkk\n\tain, kdiv, kport, kmix xin\n\nilow\t\tinit 2\nihigh\t\tinit 15\nitime\t\tinit i(gkbeats)\nif itime <= 0 then\n\titime = 1/2\nendif\nitime\t\tinit itime / 2\n\nidbthresh\tinit 9 ; dB threshold\nkoct, kdyn \tpitch ain, itime, ilow, ihigh, idbthresh\nkdyn\t\t= kdyn/pow(2, 16)\nkcps        = cpsoct(koct)\nif kdiv > 0 then\n\tkcycle\t\t= chnget:k(\"heart\") * divz(gkdiv, kdiv, 1)\n\tkoct\t\tsamphold koct, changed2(int(kcycle))\n\tkoct2\t\tvdel_k koct, gkbeats*kdiv, itime*2\nendif\n\nk1\t\t\tjitter 1, gkbeatf/24, gkbeatf/8\nk2\t\t\tjitter 1, gkbeatf/24, gkbeatf/8\nk3\t\t\tjitter 1, gkbeatf/24, gkbeatf/8\nk4\t\t\tjitter 1, gkbeatf/24, gkbeatf/8\nk5\t\t\tjitter 1, gkbeatf/24, gkbeatf/8\n\naosc1\t\tvco2 1, portk(kcps, kport)\nacheby1\t\tchebyshevpoly  aosc1, 0, k1, k2, k3, k4, k5\n\naosc2\t\tvco2 1, portk(kcps, kport)\nacheby2\t\tchebyshevpoly  aosc2, 0, k5, k4, k3, k2, k1\n\naosc\t\t= (acheby1 + acheby2/2)*portk(kdyn, kport/(1+jitter:k(.5, gkbeatf/8, gkbeatf)))\n\naout\t\t= ain*(1-kmix) + aosc*kmix\n\n\txout aout\n\tendop"
    },
    "pitchij": {
        "input": "kkk",
        "core": "PARAM_1\t\tinit 0\nPARAM_2\t\tinit gibeats/48\nPARAM_3     init .5\n\nPARAM_OUT\tcordelia_pitch PARAM_IN, PARAM_1, PARAM_2, PARAM_3",
        "opcode": "opcode cordelia_pitch, a, akkk\n\tain, kdiv, kport, kwet xin\n\nilow\t\tinit 2\nihigh\t\tinit 15\nitime\t\tinit i(gkbeats)\nif itime <= 0 then\n\titime = 1/2\nendif\nitime\t\tinit itime / 2\n\nidbthresh\tinit 9 ; dB threshold\nkoct, kdyn \tpitch ain, itime, ilow, ihigh, idbthresh\nkdyn\t\t= kdyn/pow(2, 16)\n\nif kdiv > 0 then\n\tkcycle\t\t\t= chnget:k(\"heart\") * divz(gkdiv, kdiv, 1)\n\tkoct\t\t\tsamphold koct, changed2(int(kcycle))\n\tkoct2\t\t\tvdel_k koct, gkbeats*kdiv, gibeats*2\n\taosc2\t\t\toscil3 1, portk(cpsoct(koct2)/2, kport/(1+jitter:k(.5, gkbeatf/8, gkbeatf))), gitri\nendif\n\naosc1\t\toscil3 1, portk(cpsoct(koct)/2, kport/(1+jitter:k(.5, gkbeatf/8, gkbeatf))), gitri\naosc\t\t= (aosc1 + aosc2/2)*portk(kdyn, kport/(1+jitter:k(.5, gkbeatf/8, gkbeatf)))*4\n\naout\t\t= ain*(1-kwet) + aosc*kwet\n\n\txout aout\n\tendop"
    },
    "platij": {
        "input": "k",
        "core": ";space\nPARAM_1 init 1\n\nPARAM_OUT plate_rev PARAM_IN, PARAM_1",
        "opcode": "giplate_rev_tabexcite\tftgen 0, 0, 0, -2, .35, .3875, .392575, .325, .85715, .78545\ngiplate_rev_tabouts\t\tftgen 0, 0, 0, -2, .25, .675, 1.50975, .25, .75, .51545\n\n\topcode plate_rev, a, ak\n\tain, kmix xin\n\nitime\tinit i(gkbeats)*8 \n\narev\tplaterev giplate_rev_tabexcite, giplate_rev_tabouts, 0, .095, .75, itime, .0015, ain\naout\t= ain*(1-kmix) + arev*kmix\n\n\txout aout\n\tendop"
    },
    "radio": {
        "input": "k",
        "core": "PARAM_1 init 1\n\nPARAM_OUT cordelia_radio PARAM_IN, PARAM_1",
        "opcode": "#define cordelia_radio_low_freq_jit#jitter(500, 1/32, 1/8)#\n#define cordelia_radio_high_freq_jit#jitter(1500, 1/32, 1/8)#\n\nopcode cordelia_radio, a, ak\n\tain, kwet xin\n\n\t\tkwet limit kwet, 0, 1\n\n\t\timax_dur init i(gkbeats)\n\t\timax_dur init imax_dur*8\n\n\t\twhile imax_dur < .5 do\n\t\t\timax_dur *= 2\n\t\tod\n\n\t\tarev\tinit 0\n\t\taenv_delay\tinit 0\n\n\t\taenv_pre\tfollow ain, (ksmps/sr)*8\n\t\taenv_delay\tvdelay3 aenv_pre+aenv_delay*(.75+jitter(.25, 1/32, 1/3)), 1/$M_PI, imax_dur\n\t\t\t\t\t\n\t\taenv \tsum aenv_pre, aenv_delay\n\n\t\tadust\tdust2 1, gkbeatf*256*k(aenv)\n\n\t\t; SVFILTER FREQUENCIEs BOUNDARIEs\n\t\tklow_freq\t\t= 6500 + $cordelia_radio_low_freq_jit\n\t\tkhigh_freq\t\t= 11500 + $cordelia_radio_high_freq_jit\n\n\t\ta_, a_, aband svfilter adust, randomh:k(klow_freq, khigh_freq, gkbeatf+gkbeatf*k(aenv_delay)), 5\n\n\t\t;asum\t= ain * aband/2\n\t\taconv\tcross2 ain, aband, 1024, 2, gihanning, 1\n\t\taconv\t*= 3\n\n\t\t; 2nd OUTPUT\n\t\t; SVFILTER FREQUENCIEs BOUNDARIEs\n\n\t\t; subtle wow/flutter LFO\n\t\tidepth1\t\tinit 3.5\t\t\t\t\t\n\t\tirate1 \t\tinit 1/10\n\t\tamod1 \t\toscili idepth1+jitter(1, 1/8, 1/32), irate1, giasine\n\n\t\tidepth2\t\tinit 1.5\n\t\tirate2 \t\tinit 1/7\n\t\tamod2 \t\toscili idepth2+jitter(.5, 1/8, 1/32), irate2, giasine\n\n\t\tamod \t\t= amod1 + amod2\n\n\t\tawow\t\tinit 0\n\t\tawow\t\tvdelay aconv+awow*.15, 15 + amod*10, 1000\n\n\t\tawow2\t\tinit 0\n\t\tawow2\t\tvdelay ain+awow2*.15, 5 + amod*10, 1000\n\n\n\t\tklow_freq2\t\t= 6500 + $cordelia_radio_low_freq_jit\n\t\tkhigh_freq2\t\t= 9500 + $cordelia_radio_high_freq_jit\n\n\t\ta_, a_, aband2 svfilter awow2+awow, randomh:k(klow_freq2, khigh_freq2, gkbeatf+gkbeatf*k(aenv_delay)), 5+jitter(2, 1/8, 1/32)\n\n\t\taout =  ain*(1-kwet) + aband2*kwet;*(1-kfb/4)\n\n\txout aout\nendop"
    },
    "resij": {
        "input": "kk",
        "core": "PARAM_1    init 500\nPARAM_2    init .5\n\nPARAM_OUT cordelia_res PARAM_IN, PARAM_1, PARAM_2",
        "opcode": "opcode cordelia_res, a, akk\n    ain, kfreq, kq xin\n\nilen_array      init 96\niband_high      ntof \"5B\"\n\nktuning         = gktuning\n\nkfreqs[]\tinit ilen_array\nif changed2(ktuning) == 1 then\n    klen_tuning\t\ttablekt 0, gktuning\n    kroot_tuning\ttablekt 2, gktuning\n\n    kndx\t\t= 0\n    kfreq_indx\t= 0\n    koct\t\t= 1\n    until kfreq_indx >= iband_high || kndx == ilen_array do\n        if kndx % klen_tuning == 0 then\n            koct += 1\n        endif\n\n        kfreqs[kndx]\t= koct*kroot_tuning * tablekt:k(4+(kndx % klen_tuning), ktuning)\n        kfreq_indx\t\t= kfreqs[kndx]\n        kndx += 1\n    od\nendif\n\nkbws[]\t\t\t= kfreqs / kq * 128\nabands_as[] \tpoly ilen_array, \"butterbp\", ain, kfreqs, kbws\naout \t\t\tsumarray abands_as; /pow(2, 12)\n\n    xout aout\n    endop"
    },
    "revij": {
        "input": "kkk",
        "core": "PARAM_1 init i(gkbeats) ;space\nPARAM_2 init .5 ;high freq\nPARAM_3 init .5 ;mix\n\nPARAM_OUT reverb_1 PARAM_IN, PARAM_1, PARAM_2, PARAM_3",
        "opcode": "opcode reverb_1, a, akkk\n\tain, ktime, khigh_freq, kmix xin\n\narev\tnreverb ain, ktime, 1-khigh_freq\naout\t= ain*(1-kmix) + arev*kmix\n\n\txout aout\n\tendop"
    },
    "revijd": {
        "input": "kkk",
        "core": "PARAM_1 init i(gkbeats) ;space\nPARAM_2 init .5 ;high freq\nPARAM_3 init .5 ;mix\n\nPARAM_OUT cordelia_reverb_dust PARAM_IN, PARAM_1, PARAM_2, PARAM_3",
        "opcode": "opcode cordelia_reverb_dust, a, akkk\n\tain, ktime, khigh_freq, kwet xin\n\n\t\timaxdur init i(gkbeats)\n\t\timaxdur init imaxdur*8\n\n\t\twhile imaxdur < .5 do\n\t\t\timaxdur *= 2\n\t\tod\n\n\t\tarev\tinit 0\n\n\t\taenv\tfollow ain, ksmps/sr\n\t\tadust\tdust2 1, gkbeatf*256*k(aenv)\n\t\ta_, a_, aband svfilter adust, randomh(5000, 9000, gkbeatf+gkbeatf*k(aenv)), 0\n\n\t\tarev\tnreverb (aband/8+ain)*kwet, ktime, 1-khigh_freq\n\n\t\tilen_samps = imaxdur * sr\n\t\tibuf ftgentmp 0, 0, ilen_samps, -2, 0\n\n\t\tandx = phasor(1/ktime)*a(ktime*sr)\n\t\ttablew arev, andx, ibuf\n\n\t\tadist = a(abs(jitter:k(1, .25/ktime, 1/ktime))*ktime*sr)\n\t\taout1 table vdelay(andx, ktime*1000, imaxdur), ibuf\n\t\taout2 table vdelay(adist, ktime*1000, imaxdur), ibuf\n\t\t;aout *= table3:a(delay((phasor:a(1/ktime)), 1/sr*ksmps*4), gihamming, 1)\n\t\t;arev_last\tnreverb aout, ktime*2, 1-khigh_freq\n\t\t;aout =  ain*(1-kwet) + kwet*(aout1 + aout2)/3;*(1-kfb/4)\n\t\taout =  ain*(1-kwet) + kwet*(aout1 + aout2);*(1-kfb/4)\n\n\txout aout\nendop"
    },
    "revijd2": {
        "input": "kkk",
        "core": "PARAM_1 init i(gkbeats) ;space\nPARAM_2 init .5 ;high freq\nPARAM_3 init .5 ;mix\n\nPARAM_OUT cordelia_reverb_dust PARAM_IN, PARAM_1, PARAM_2, PARAM_3",
        "opcode": "opcode cordelia_reverb_dust, a, akkk\n\tain, ktime, khigh_freq, kwet xin\n\n\t\timaxdur init i(gkbeats)\n\t\timaxdur init imaxdur*8\n\n\t\twhile imaxdur < .5 do\n\t\t\timaxdur *= 2\n\t\tod\n\n\t\tarev\tinit 0\n\n\t\taenv\tfollow ain, 1/ksmps\n\t\tadust\tdust2 1, gkbeatf*256*k(aenv)\n\t\ta_, a_, aband svfilter adust, randomh(5000, 9000, gkbeatf+gkbeatf*k(aenv)), 0\n\n\t\tarev\tnreverb (aband/8+ain)*kwet, ktime, 1-khigh_freq\n\n\t\tilen_samps = imaxdur * sr\n\t\tibuf ftgentmp 0, 0, ilen_samps, -2, 0\n\n\t\tandx = phasor(1/ktime)*a(ktime*sr)\n\t\ttablew arev, andx, ibuf\n\n\t\tadist = a(abs(jitter:k(1, .25/ktime, 1/ktime))*ktime*sr)\n\t\taout1 table vdelay(andx, ktime*1000, imaxdur), ibuf\n\t\taout2 table vdelay(adist, ktime*1000, imaxdur), ibuf\n\t\t;aout *= table3:a(delay((phasor:a(1/ktime)), 1/sr*ksmps*4), gihamming, 1)\n\t\t;arev_last\tnreverb aout, ktime*2, 1-khigh_freq\n\t\taout =  ain*(1-kwet) + (aout1 + aout2)/3;*(1-kfb/4)\n\n\txout aout\nendop"
    },
    "rinij": {
        "input": "kk",
        "core": ";division\nPARAM_1 init 4\n\n;gen\nPARAM_2 init giasine\n\nPARAM_OUT cordelia_ringmod PARAM_IN, PARAM_1, PARAM_2",
        "opcode": "opcode cordelia_ringmod, a, akk\n\tain, kdiv, ktab xin\n\nkexists ftexists ktab\nif kexists != 1 then\n\tktab = giasine\n\tprintks \"WARNING ***RINIJ*** PARAM_2 IS TAB\\n\", 1/2\nendif\n\nkphase\t\t= kdiv - floor(kdiv)\nandx\t\t= ((chnget:a(\"heart_a\")*kdiv*gkdiv)+kphase)%1\n\nkwarp\tinit 0; if greater than 1, use sin (x / kwarp) / x function for sinc interpolation, instead of the default sin (x) / x. This is useful to avoid aliasing when transposing up (kwarp should be set to the transpose factor in this case, e.g. 2.0 for one octave), however it makes rendering up to twice as slow. Also, iwsize should be at least kwarp * 8. This feature is experimental, and may be optimized both in terms of speed and quality in new versions.\niwsize\tinit 4*16; This parameter controls the type of interpolation to be used:\nimode\tinit 1\nioff\tinit 0\niwrap\tinit 1 ;wraparound index flag. The default value is 0.\n\naring\t\ttablexkt andx, ktab, kwarp, iwsize, imode, ioff , iwrap\n\naout\t\t= ain * aring\n\n\txout aout\n\tendop"
    },
    "sendch": {
        "input": "kk",
        "core": "PARAM_2\tgenarray_i 1, ginchnls\nPARAM_3\tinit .5\n\nPARAM_OUT cordelia_sendch PARAM_IN, ich, PARAM_1, PARAM_2",
        "opcode": "opcode cordelia_sendch, a, aii[]k\n    ain, ich, ichs[], kmix xin\n\nilen        lenarray ichs\nindx        init 1\nuntil indx > ginchnls do\n    chnmix ain, gSmouth[indx]\nod\n\naout\t    = ain*(1-kmix)\n\n    xout aout\n    endop"
    },
    "shij": {
        "input": "kkkk",
        "core": "PARAM_1    init .5\nPARAM_2    init .45\nPARAM_3    init 2\nPARAM_4    init .5\n\nPARAM_OUT cordelia_shimmer_reverb PARAM_IN, PARAM_1, PARAM_2, PARAM_3, PARAM_4",
        "opcode": "opcode cordelia_shimmer_reverb, a, akkkk\n    ain, ktime, kfb, kratio, kwet xin\n\n; Author: Steven Yi\nimaxdel     init 15000\n\n; pre-delay\nadel        vdelay3 ain*kwet, a(ktime*1000), imaxdel\n\nafb         init 0\n\nadel        = adel + (afb * a(kfb))\n\n; important, or signal bias grows rapidly\nadel        dcblock2 adel\nadel        tanh adel\n\na_          = 0\nadel, a_    reverbsc adel, a_, limit(kfb*2, 0, .95), sr / 3\n\nifftsize    init 4096 \nioverlap    init ifftsize / 4 \niwinsize    init ifftsize \niwinshape   init 1 ; von-Hann window \n\nfftin       pvsanal adel, ifftsize, ioverlap, iwinsize, iwinshape \nfftscale    pvscale fftin, kratio, 0, 1\natrans      pvsynth fftscale\n\n; delay the feedback to let it build up over time\nafb         vdelay3 atrans, a(ktime*1000), imaxdel\naout         =  ain*(1-kwet) + adel*(1-kfb/4)/2\n\n    xout aout\n\n    endop"
    },
    "skh": {
        "input": "kkk",
        "core": "PARAM_1    init 500\nPARAM_2    init .5\nPARAM_3    init .5\n\nPARAM_OUT cordelia_skh PARAM_IN, PARAM_1, PARAM_2, PARAM_3",
        "opcode": "opcode cordelia_skh, a, akkk\n    ain, kfreq, kq, kwet xin\n\nifreq_var\tinit 5\naskh\tskf ain*kwet, a(kfreq+jitter:k(ifreq_var, gkbeatf/8, gkbeatf)), 1+(kq*3), 1\n;aout\tbalance aout, ain\n\naout         =  ain*(1-kwet) + askh ; kwet is already in the delay\n\n\n    xout aout\n    endop"
    },
    "skhp": {
        "input": "kk",
        "core": "PARAM_1    init 2\nPARAM_2    init .5\n\nPARAM_OUT cordelia_skhp PARAM_IN, PARAM_1, PARAM_2",
        "opcode": "opcode cordelia_skhp, a, akk\n    ain, kfreq, kq xin\n\nilow\t\tinit 2\nihigh\t\tinit 15\nitime\t\tinit i(gkbeats)\nidbthresh\tinit 9 ; dB threshold\n\nkoct, kdyn \tpitch ain, itime/32, ilow, ihigh, idbthresh\n\nifreq_var\tinit 5\naout\tskf ain, a(portk(cpsoct(koct), .005)*kfreq+jitter:k(ifreq_var, gkbeatf/8, gkbeatf)), 1+(kq*3), 1\n;aout\tbalance aout, ain\n\n    xout aout\n    endop"
    },
    "skl": {
        "input": "kk",
        "core": "PARAM_1    init 500\nPARAM_2    init .5\n\nPARAM_OUT cordelia_skl PARAM_IN, PARAM_1, PARAM_2",
        "opcode": "opcode cordelia_skl, a, akk\n    ain, kfreq, kq xin\n\nifreq_var\tinit 5\naout\tskf ain, portk(kfreq+jitter:k(ifreq_var, gkbeatf/8, gkbeatf), 5$ms), 1+(kq*3), 0\naout\tbalance2 aout, ain\n\n    xout aout\n    endop"
    },
    "sklb": {
        "input": "kk",
        "core": "PARAM_1    init 500\nPARAM_2    init .5\n\nPARAM_OUT cordelia_sklb PARAM_IN, PARAM_1, PARAM_2",
        "opcode": "gkcordelia_sklb_port init 5$ms\ngkcordelia_sklb_freq init 3\n\n    opcode cordelia_sklb, a, akk\n    ain, kfreq, kq xin\n\nifreq_var\tinit 5\n\nkfreq1  limit kfreq + jitter:k(ifreq_var, gkbeatf/8, gkbeatf), 20, 20$k\na1      skf ain, portk(kfreq1, gkcordelia_sklb_port), 1+(kq*3), 0\n\na0      init 0\nkfreq2  limit gkcordelia_sklb_freq*kfreq + jitter:k(ifreq_var, gkbeatf/8, gkbeatf), 20, 20$k\na2      spf a0, a0, ain, portk(kfreq2, gkcordelia_sklb_port), 2-(kq*2)\n\naout    = a1 + a2\n\naout\tbalance2 aout, ain\n\n    xout aout\n    endop"
    },
    "sklb3": {
        "input": "kk",
        "core": "PARAM_1    init 500\nPARAM_2    init .5\n\nPARAM_OUT cordelia_sklb3 PARAM_IN, PARAM_1, PARAM_2",
        "opcode": "gkcordelia_sklb3_port init 5$ms\ngkcordelia_sklb3_freq1 init 3\ngkcordelia_sklb3_freq2 init 4\ngkcordelia_sklb3_freq3 init 5\n\n    opcode cordelia_sklb3, a, akk\n    ain, kfreq, kq xin\n\nifreq_var\tinit 5\n\nkfreq1  limit kfreq + jitter:k(ifreq_var, gkbeatf/8, gkbeatf), 20, 20$k\na1      skf ain, portk(kfreq1, gkcordelia_sklb3_port), 1+(kq*3), 0\n\na0      init 0\nkfreq2  limit gkcordelia_sklb3_freq1*kfreq + jitter:k(ifreq_var, gkbeatf/8, gkbeatf), 20, 20$k\na2      spf a0, a0, ain, portk(kfreq2, gkcordelia_sklb3_port), 2-(kq*2)\n\nkfreq3  limit gkcordelia_sklb3_freq2*kfreq + jitter:k(ifreq_var, gkbeatf/8, gkbeatf), 20, 20$k\na3      spf a0, a0, ain, portk(kfreq3, gkcordelia_sklb3_port), 2-(kq*2)\n\nkfreq4  limit gkcordelia_sklb3_freq3*kfreq + jitter:k(ifreq_var, gkbeatf/8, gkbeatf), 20, 20$k\na4      spf a0, a0, ain, portk(kfreq4, gkcordelia_sklb3_port), 2-(kq*2)\n\naout    = a1 + a2 + a3 + a4\n\naout\tbalance2 aout, ain\n\n    xout aout\n    endop"
    },
    "solij": {
        "input": "kk",
        "core": "PARAM_1 init i(gkbeats)\nPARAM_2\tinit .5\n\nPARAM_OUT    solina_chorus PARAM_IN, PARAM_1, PARAM_2",
        "opcode": "/* Solina Chorus, based on Solina String Ensemble Chorus Module\n  \n   based on:\n\n   J. Haible: Triple Chorus\n   http://jhaible.com/legacy/triple_chorus/triple_chorus.html\n\n   Hugo Portillo: Solina-V String Ensemble\n   http://www.native-instruments.com/en/reaktor-community/reaktor-user-library/entry/show/4525/ \n\n   Parabola tabled shape borrowed from Iain McCurdy delayStereoChorus.csd:\n   http://iainmccurdy.org/CsoundRealtimeExamples/Delays/delayStereoChorus.csd\n\n   Author: Steven Yi\n   Date: 2016.05.22\n\n   */\n\n\tgi_solina_parabola ftgen 0, 0, 65537, 19, 0.5, 1, 180, 1 \n\n\t;; 3 sine wave LFOs, 120 degrees out of phase\n\topcode sol_lfo_3, aaa, kk\n\tkfreq, kamp xin\n\naphs\tphasor kfreq\n\na0\t\ttablei aphs, gi_solina_parabola, 1, 0, 1\na120\ttablei aphs, gi_solina_parabola, 1, 0.333, 1\na240\ttablei aphs, gi_solina_parabola, 1, -0.333, 1\n\n\txout (a0 * kamp), (a120 * kamp), (a240 * kamp)\n\tendop\n\n\topcode solina_chorus, a, akk\n\n\taLeft, klfo_freq1, klfo_amp1 xin\n\nklfo_freq2 = klfo_freq1*3\nklfo_amp2 = klfo_amp1*3\n\nimax = 100\n\n;; slow lfo\nas1, as2, as3 sol_lfo_3 klfo_freq1, klfo_amp1\n\n;; fast lfo\naf1, af2, af3  sol_lfo_3 klfo_freq2, klfo_amp2\n\nat1 = limit(as1 + af1 + 5, 0, imax)\nat2 = limit(as2 + af2 + 5, 0, imax)\nat3 = limit(as3 + af3 + 5, 0, imax)\n\t\na1 vdelay3 aLeft, at1, imax \na2 vdelay3 aLeft, at2, imax \na3 vdelay3 aLeft, at3, imax \n\n\txout (a1 + a2 + a3) / 3\n\tendop"
    },
    "strij": {
        "input": "kk",
        "core": ";division\nPARAM_1 init ntof(\"4B\")\n\n;gen\nPARAM_2 init .5\n\nPARAM_OUT cordelia_streson PARAM_IN, PARAM_1, PARAM_2",
        "opcode": "gicordelia_streson_limit init .95\ngicordelia_streson_thr init .75\ngicordelia_streson_range init gicordelia_streson_limit - gicordelia_streson_thr\n\n\topcode cordelia_streson, a, akk\n\tain, kfreq, kq xin\n\n; light, shallow compensation on resonance\n; or it can explode..\nkq      limit kq, 0, gicordelia_streson_limit\nkratio  = max(kq - gicordelia_streson_thr, 0) / gicordelia_streson_range\nkdyn    = 1 - (kratio * gicordelia_streson_range)\n\nkfreq += oscili:k(.5, gkbeatf/64)\n\naguid\twguide1 ain, 1/kfreq, kfreq/2, kq\n\nastr1\tstreson ain, kfreq, kq\nastr2\tstreson ain, kfreq*1.25, kq\n\naout\t= aguid + astr1 + astr2\naout\t/= 3\n\naout\tphaser1 aout*kdyn, kfreq, 12, kq\naout\tbutterhp aout, 20\n\txout aout\n\tendop"
    },
    "strijp": {
        "input": "kkk",
        "core": ";division\nPARAM_1 init ntof(\"4B\")\n\n;gen\nPARAM_2 init i(gkbeats)/24\n\nPARAM_3 init .5\n\nPARAM_OUT cordelia_streson_p PARAM_IN, PARAM_1, PARAM_2, PARAM_3",
        "opcode": "opcode cordelia_streson_p, a, akkk\n\tain, kfreq, kport, kq xin\n\nkfreq\tportk kfreq, kport\n\naguid\twguide1 ain, 1/kfreq, kfreq/2, kq\n\nastr1\tstreson ain, kfreq, kq\nastr2\tstreson ain, kfreq*1.25, kq\n\naout\t= aguid + astr1 + astr2\naout\t/= 3\n\naout\tphaser1 aout, kfreq, 12, kq\n\t\n\txout aout\n\tendop"
    },
    "strijp2": {
        "input": "kkk",
        "core": ";division\nPARAM_1 init ntof(\"4B\")\n\n;gen\nPARAM_2 init i(gkbeats)/24\n\nPARAM_3 init .5\n\nPARAM_OUT cordelia_streson_p2 PARAM_IN, PARAM_1, PARAM_2, PARAM_3",
        "opcode": "opcode cordelia_streson_p2, a, akkk\n\tain, kfreq, kport, kq xin\n\n#define cordelia_streson_p2_q #limit(kq+jitter:k(kq/3, gkbeatf/16, gkbeatf), .05, .95)#\n\nkfreq\tportk kfreq, kport\n\naguid\twguide1 ain, 1/kfreq, kfreq/2, $cordelia_streson_p2_q\n\nastr1\tstreson ain, kfreq, $cordelia_streson_p2_q\nastr2\tstreson ain, kfreq*3/2, $cordelia_streson_p2_q\n\naout\t= aguid + astr1 + astr2\naout\t/= 3\n\naout\tphaser1 aout, kfreq, 12, $cordelia_streson_p2_q\n\t\n\txout aout\n\tendop"
    },
    "tape": {
        "input": "kk",
        "core": "PARAM_1    init 3.5 ; drive factor (increase for more distortion)\nPARAM_2    init .65\n\nPARAM_OUT cordelia_moogladder2 PARAM_IN, PARAM_1, PARAM_2",
        "opcode": "; === TAPE SATURATION UDO ===\nopcode tape_saturation, a, akk\n    ain, kdrive, kwet xin\n\n    ; nonlinear soft clipper (arctangent shaping)\n    asat = tanh(kdrive * ain)\n\n    aout = (1 - kwet) * ain + kwet * asat\n\n    ; slight lowpass for analog feel\n    aout tone aout, 8000\n\n    xout aout\nendop"
    },
    "tapij": {
        "input": "kkk",
        "core": "PARAM_1\t\tinit i(gkbeats)\nPARAM_2\t\tinit .5\nPARAM_3\t\tinit .5\n\nPARAM_OUT\tcordelia_tapij PARAM_IN, PARAM_1, PARAM_2, PARAM_3",
        "opcode": "; Original research and code by Jon Downing  as in paper\n; Real-time digital modeling of the Roland Space Echo by Jon Downing, Christian Terjesen (ECE 472 - Audio Signal Processing, May 2016)\n;\n; Reimplemented in Csound by Anton Kholomiov\n\n; Error function approximation ~ 2% accuracy\nopcode ErrorFunApprox, a, a\n  aIn xin\n  kCoeff init ( (3.1415926535 ^ 0.5) * log(2) )\n  xout tanh(kCoeff * aIn)\nendop\n\n; Bandpass Chebyshev Type I filter\nopcode bandpassCheby1, a, akkii\n  aIn, kLowFreq, kHighFreq, iOrder, iRipple xin\n\n  aHigh clfilt aIn,   kLowFreq,  1, iOrder, 1, iRipple\n  aLow  clfilt aHigh, kHighFreq, 0, iOrder, 1, iRipple\n\n  xout aLow\nendop\n\n; Function to read from tape.\n;\n; tapeRead aIn, kDelay, kRandomSpread\n;\n; The function is used in the same manner as deltapi\n; first init the delay buffer and the use tapeRead.\n;\n; aIn - input signal\n; kDelay - delay time\n; kRandomSpread - [0, Inf] - the random spread of reading from the tape\n;    the higher the worser the quality of the tape.\nopcode tapeRead, a, akk\n  aIn, kDelay, kRandomSpread xin\n  iTauUp = 1.07\n  iTauDown = 1.89\n  aPrevDelay init 0.06\n  kOldDelay  init 0.06\n  kLambda init 0.5\n\n  kDelChange changed2 kDelay\n  if (kDelChange == 1) then\n    if (kOldDelay < kDelay) then\n      kLambda = exp(-1/(iTauUp*sr))\n    else\n      kLambda = exp(-1/(iTauDown*sr))\n    endif\n  endif\n\n  anoise noise kRandomSpread, 0\n  anoise = 3*(7.5 - aPrevDelay*(10^-3))*(10^-7)*anoise\n  anoiseMod butterlp anoise, 0.25  ; (0.5 / sr) * giNyquistFreq\n  aActualDelay = (1 - kLambda) * kDelay + kLambda * aPrevDelay + anoiseMod\n  aPrevDelay = aActualDelay\n                                         ; measured\n  aDelaySamps = aActualDelay * sr\n  aReadSr = floor(aDelaySamps)          ; in samples\n  aLastSr = aReadSr + 1                 ; in samples\n  aReadIndex = aReadSr / sr             ; in seconds\n  aLastIndex = aLastSr / sr             ; in seconds\n  aFrac = aDelaySamps - aReadSr\n  aFracScale = (1 - aFrac) * (1 + aFrac)\n\n  aReadSample deltapi aReadIndex\n  aLastSample deltapi aLastIndex\n\n  aEcho ErrorFunApprox (aLastSample + aFracScale * (aReadSample - aLastSample))\n\n  kOldDelay = kDelay\n  xout aEcho\nendop\n\n; function to write to tape\n;\n; tapeWrite aIn, aOut, kFbGain\n;\n; It should be though of as delayw for magnetic tape.\n;\n; aIn - input signal\n; aOut - output signal\n; kFbGain - gain of feedback [0, 2]\nopcode tapeWrite, 0, aak\n  aIn, aOut, kFbGain xin\n  iOrder    = 2\n  iRippleDb = 6\n  aProc bandpassCheby1 aOut * kFbGain, 95, 3000, iOrder, iRippleDb\n  delayw aIn + aProc * kFbGain\nendop\n\n; Simple tape delay effect with tone-color.\n;\n; aIn - input signal\n; kDelay - delay time\n; kEchoGain - gain for the echo\n; kFbGain - feedback gain\n; kTone - color of the low-pass filter (frequency for the filter)\n; kRandomSpread - radius of noisy reading from the tape [0.5, Inf] - relates to \"tape age\".\n;   smaller - the better tape is\nopcode TapeEcho1, a, akkkkk\n  aIn, kDelay, kEchoGain, kFbGain, kTone, kRandomSpread xin\n\n  aDummy delayr 16\n  aEcho tapeRead aIn, kDelay, kRandomSpread\n  aOut  = aIn + kEchoGain * aEcho\n\n  aOut tone aOut, kTone\n  tapeWrite aIn, aOut, kFbGain\n  xout aOut\nendop\n\n\nopcode TapeEcho3, a, akkkkk\n  aIn, kDelay, kEchoGain, kFbGain, kTone, kRandomSpread xin\n\n  aDummy delayr 16\n  aEcho1 tapeRead aIn, kDelay, kRandomSpread\n  aEcho2 tapeRead aIn, (kDelay * 2), kRandomSpread\n  aEcho3 tapeRead aIn, (kDelay * 4), kRandomSpread\n  aOut  = aIn + kEchoGain * aEcho1 + 0.5 * kEchoGain * aEcho2 + 0.25 * kEchoGain * aEcho3\n\n  aOut tone aOut, kTone\n  tapeWrite aIn, aOut, kFbGain\n  xout aOut\nendop\n\nopcode TapeEcho4, a, akkkkk\n  aIn, kDelay, kEchoGain, kFbGain, kTone, kRandomSpread xin\n\n  aDummy delayr 16\n  aEcho1 tapeRead aIn, kDelay, kRandomSpread\n  aEcho2 tapeRead aIn, (kDelay * 2), kRandomSpread\n  aEcho3 tapeRead aIn, (kDelay * 4), kRandomSpread\n  aEcho4 tapeRead aIn, (kDelay * 8), kRandomSpread\n  aOut  = aIn + kEchoGain * aEcho1 + 0.5 * kEchoGain * aEcho2 + 0.25 * kEchoGain * aEcho3  + 0.2 * kEchoGain * aEcho4\n\n  aOut tone aOut, kTone\n  tapeWrite aIn, aOut, kFbGain\n  xout aOut\nendop\n\n\nopcode tapeReadBatch, a, akkii\n  aIn, kDelay, kRandomSpread, iSize, iStart xin\n\n  if iStart <= iSize then\n    acall tapeReadBatch aIn, kDelay, kRandomSpread, iSize, iStart + 1\n  else\n    acall = 0\n  endif\n\n  iScale = iStart\n  aEcho tapeRead aIn, kDelay * iScale, kRandomSpread\n  xout acall + aEcho / iScale\nendop\n\nopcode TapeEchoN, a, akkkkki\n  aIn, kDelay, kEchoGain, kFbGain, kTone, kRandomSpread, iSize xin\n  aDummy delayr (16 * iSize)\n  aEcho tapeReadBatch aIn, kDelay, kRandomSpread, iSize, 1\n  aOut = aIn + kEchoGain * aEcho\n  tapeWrite aIn, aOut, kFbGain\n  xout aOut\nendop\n\n\nopcode  cordelia_tapij, a, akkk\nain, ktime, kfb, kmix xin\n\nkdel  = ktime\nkvar\tjitter .25, gkbeatf/8, gkbeatf\n\nadel\tTapeEchoN ain, kdel, kfb, .95, 0, .75 + kvar, 10\naout\t= ain*(1-kmix) + adel*kmix\n\n  xout aout\n\n    endop"
    },
    "vbp": {
        "input": "kkk",
        "core": "PARAM_1     init 200\nPARAM_2     init 6500\nPARAM_3     init .5\n\nPARAM_OUT cordelia_vapor_bandpass PARAM_IN, PARAM_1, PARAM_2, PARAM_3",
        "opcode": "opcode cordelia_vapor_bandpass, a, akkk\n\tain, klow, khigh, kwet xin\n\nalow  \ttone ain*kwet, klow\nahigh \tbuthp ain*kwet, khigh\n\naout\t= ain * (1-kwet) + (alow - ahigh)\n\n    xout aout \n\tendop"
    },
    "vbp2": {
        "input": "kkk",
        "core": "PARAM_1     init 200\nPARAM_2     init 6500\nPARAM_3     init .5\n\nPARAM_OUT cordelia_vapor_bandpass2 PARAM_IN, PARAM_1, PARAM_2, PARAM_3",
        "opcode": "opcode cordelia_vapor_bandpass2, a, akkk\n\tain, klow, khigh, kwet xin\n\nalow  \ttone ain*kwet, klow\nahigh \tbuthp ain*kwet, khigh\n\naout\t= ain * (1-kwet) + (ahigh - alow)\n\n    xout aout \n\tendop"
    },
    "vcorus": {
        "input": "kkk",
        "core": "PARAM_1     init 35\nPARAM_2     init .35\nPARAM_3     init 1\n\nPARAM_OUT cordelia_vapor_chorus PARAM_IN, PARAM_1, PARAM_2, PARAM_3",
        "opcode": "opcode cordelia_vapor_chorus, a, akkk\n\tain, kdel, kfb, kwet xin\n\nidel_max\tinit 1/3\nidepth \t\tinit .0075\nirate\t\tinit .25\n\naout\tinit 0\namod\toscili idepth, irate+jitter(.05, 1/8, 1/32)\n\n;ares vdelay3 asig, adel, imaxdel [, iskip]\naout\tvdelay3 ain+aout*kfb, kdel/1000 + amod, idel_max\n\n\txout aout\n\tendop"
    },
    "vdel": {
        "input": "kkk",
        "core": "PARAM_1     init .35\nPARAM_2     init .5\nPARAM_3     init .5\n\nPARAM_OUT cordelia_vapor_delay PARAM_IN, PARAM_1, PARAM_2, PARAM_3",
        "opcode": "opcode cordelia_vapor_delay, a, akkk\n\tain, kdel, kfb, kwet xin\n\napre\t\tdelayr .35\nadel    \tdeltap .35\naout \t\t= ain + apre\n\n\tdelayw ain + adel * kfb * kwet\n\n\txout ain*(1-kwet)+aout\n\tendop"
    },
    "vocij": {
        "input": "Skkkk",
        "core": "; PARAM_1 String\nPARAM_2\tinit 95\nPARAM_3\tinit .5 ; mix\nPARAM_4\tinit 30 ; min\nPARAM_5\tinit 13.5$k ; max\n\n\nPARAM_OUT cordelia_vocoder PARAM_IN, PARAM_1, PARAM_2, PARAM_3, PARAM_4, PARAM_5, ich",
        "opcode": "opcode cordelia_vocoder, a, aSkkkkipp\nain, Sinstr, kq, kwet, kmin, kmax, ich, iband, icount xin\n\niband init 24\nadest   chnget sprintf(\"%s_%i\", Sinstr, ich)\n\nif kmax < kmin then\n    ktmp = kmin\n    kmin = kmax\n    kmax = ktmp\nendif\n\nif kmin == 0 then \n    kmin = 1\nendif\n\nif (icount >= iband) goto bank\naband   cordelia_vocoder ain, Sinstr, kq, kwet, kmin, kmax, ich, iband, icount + 1\n\nbank:\n    kfreq = kmin*(kmax/kmin)^((icount-1)/(iband-1))\n    ;kfreq tab icount - 1, giFrqTable\n    kbw = kfreq/kq\n    an  butterbp  ain, kfreq, kbw\n    an  butterbp  an, kfreq, kbw\n    as  butterbp  adest, kfreq, kbw\n    as  butterbp  as, kfreq, kbw\n    ao  balance as, an\n\naout = ao + aband\n\naout\t    = aout*kwet + ain*(1-kwet)\n\nxout aout\n    endop"
    },
    "vocij2": {
        "input": "Skkk",
        "core": "; PARAM_1 String\nPARAM_2\tinit 128\nPARAM_3\tinit 1\nPARAM_4\tinit .5\n\nPARAM_OUT cordelia_lpc_vocoder PARAM_IN, PARAM_1, PARAM_2, PARAM_3, PARAM_4, ich",
        "opcode": "opcode cordelia_lpc_vocoder, a, aSkkki\nain, Sinstr, kperiod, kdyn, kwet, ich xin\n\nacarrier    chnget sprintf(\"%s_%i\", Sinstr, ich)\nisize       init 4096\niord        init 30         ; also the number of coefficients computed, typical lp orders may range from about 30 to 100 coefficients, but larger values can also be used.\niflag       init 1          ; compute flag, non-zero values switch on linear prediction analysis replacing filter coefficients, zero switch it off, keeping current filter coefficients.\n\naout        lpcfilter ain, acarrier, iflag, kperiod, isize, iord\n\naout        = aout*kwet*kdyn + ain*(1-kwet)\n\n    xout aout\n    endop"
    },
    "vocij3": {
        "input": "Skk",
        "core": "; PARAM_1 String\nPARAM_2\tinit 1\nPARAM_3\tinit .5\n\n\nPARAM_OUT cordelia_vocoder_pvsvoc PARAM_IN, PARAM_1, PARAM_2, PARAM_3, ich",
        "opcode": "opcode cordelia_vocoder_pvsvoc, a, aSkki\nain, Sinstr, kdyn, kwet, ich xin\n\nacarrier   chnget sprintf(\"%s_%i\", Sinstr, ich)\n\n;ain, ifftsize, ioverlap, iwinsize, iwintype\nifft_size   init 4096\nioverlap    init ifft_size / 4\niwin_size   init ifft_size\niwin        init 1\n\nfsig pvsanal ain, ifft_size, ioverlap, iwin_size, iwin   ;analyse in signal\nfexc pvsanal acarrier, ifft_size, ioverlap, iwin_size, iwin   ;analyse excitation signal\n\n; fsig, fexc, kdepth, kgain\nftps pvsvoc fsig, fexc, 1, 1            ;cross it\naout pvsynth ftps                       ;synthesise it\n\n;aout    *= kdyn\naout\t    = aout*kwet*kdyn + ain*(1-kwet)\n\nxout aout\n    endop"
    },
    "vrev": {
        "input": "kkk",
        "core": "PARAM_1     init 9500\nPARAM_2     init .35\nPARAM_3     init .5\n\nPARAM_OUT cordelia_vapor_reverb PARAM_IN, PARAM_1, PARAM_2, PARAM_3",
        "opcode": "opcode cordelia_vapor_reverb, a, akkk\n\tain, kfreq_cutoff, kfblvl, kwet xin\n\n\na1, a2 reverbsc ain*kwet, K35_hpf(ain, kfreq_cutoff, .65, 1, 1.5), kfblvl, kfreq_cutoff\n\naout\t= ain*(1-kwet) + a1 + a2\n\n\txout aout\n\tendop"
    },
    "vrev2": {
        "input": "kkk",
        "core": "PARAM_1     init 9500\nPARAM_2     init .35\nPARAM_3     init .5\n\nPARAM_OUT cordelia_vapor_reverb2 PARAM_IN, PARAM_1, PARAM_2, PARAM_3",
        "opcode": "opcode cordelia_vapor_reverb2, a, akkk\n\tain, kfreq_cutoff, kfblvl, kwet xin\n\n\na1, a2 reverbsc ain*kwet, K35_hpf(ain, kfreq_cutoff, .75+jitter(.15, gkbeatf/8, gkbeatf/32), 1, 2.5+jitter(1, gkbeatf/8, gkbeatf/32)), kfblvl, kfreq_cutoff\n\naout\t= ain*(1-kwet) + a1 + a2\n\n\txout aout\n\tendop"
    },
    "vtape": {
        "input": "kkk",
        "core": "PARAM_1     init 2.5\nPARAM_2     init 7500\nPARAM_3     init 1\n\nPARAM_OUT cordelia_tape_saturation PARAM_IN, PARAM_1, PARAM_2, PARAM_3",
        "opcode": "opcode cordelia_tape_saturation, a, akkk\n\tain, kdrive, kcutoff, kwet xin\n\nasat \t= tanh(kdrive * ain * kwet)\nasat \ttone asat, kcutoff\naout \t= ain * (1-kwet) + asat\n\n\txout aout\n\tendop"
    },
    "wooden": {
        "input": "kk",
        "core": "PARAM_1    init 500\nPARAM_2    init .5\n\nPARAM_OUT cordelia_wooden PARAM_IN, PARAM_1, PARAM_2",
        "opcode": "#define cordelia_wooden_cps(main_freq) #$main_freq+(cent(25)*jitter:k(1, gkbeatf/8, gkbeatf))#\n#define cordelia_wooden_q(main_freq) #$main_freq+jitter:k(1, gkbeatf/8, gkbeatf)#\n\n    opcode cordelia_wooden, a, akk\n    ain, kfreq, kq xin\n\nif1     init 1000\nif2     init 3000\n\niq1     init 12\niq2     init 8\n\naexc1    mode ain, $cordelia_wooden_cps(if1), $cordelia_wooden_q(iq1)\naexc2    mode ain, $cordelia_wooden_cps(if2), $cordelia_wooden_q(iq2)\n\naexc    = (aexc1+aexc2)/2\n;aexc    limit aexc, 0, 1\n\nares1   mode aexc,  $cordelia_wooden_cps(kfreq),  $cordelia_wooden_q(scale(kq, 500, 60))\nares2   mode aexc,  $cordelia_wooden_cps(kfreq*2),  $cordelia_wooden_q(scale(kq, 420, 53))\n\naout    = (ares1+ares2)/2\n\naout    balance2 aout, ain\n\n    xout aout\n    endop"
    },
    "wooden2": {
        "input": "kk",
        "core": "PARAM_1    init 1\nPARAM_2    init .5\n\nPARAM_OUT cordelia_wooden2 PARAM_IN, PARAM_1, PARAM_2",
        "opcode": "#define cordelia_wooden2_cps(main_freq) #$main_freq+(cent(25)*jitter:k(1, gkbeatf/8, gkbeatf))#\n#define cordelia_wooden2_q(main_freq) #$main_freq+jitter:k(1, gkbeatf/8, gkbeatf)#\n\n    opcode cordelia_wooden2, a, akk\n    ain, kfreq, kq xin\n\nif1     init 1000\nif2     init 3000\n\niq1     init 12\niq2     init 8\n\nilow\t\tinit 2\nihigh\t\tinit 15\nitime\t\tinit i(gkbeats)\nif itime <= 0 then\n\titime = 1/2\nendif\nitime\t\tinit itime / 2\nidbthresh\tinit 9 ; dB threshold\n\nkoct, kamp \tpitch ain, itime, ilow, ihigh, idbthresh\n\n\naexc1    mode ain, $cordelia_wooden2_cps(if1), $cordelia_wooden2_q(iq1)\naexc2    mode ain, $cordelia_wooden2_cps(if2), $cordelia_wooden2_q(iq2)\n\naexc    = (aexc1+aexc2)/2\n;aexc    limit aexc, 0, 1\n\nares1   mode aexc, $cordelia_wooden2_cps(cpsoct(koct))*kfreq, $cordelia_wooden2_q(scale(kq, 500, 60))\nares2   mode aexc, $cordelia_wooden2_cps(cpsoct(koct))*kfreq, $cordelia_wooden2_q(scale(kq, 420, 53))\n\naout    = (ares1+ares2)/2\n\naout    balance2 aout, ain\n\n    xout aout\n    endop"
    },
    "wooden3": {
        "input": "kk",
        "core": "PARAM_1    init 1\nPARAM_2    init .5\n\nPARAM_OUT cordelia_wooden3 PARAM_IN, PARAM_1, PARAM_2",
        "opcode": "#define cordelia_wooden3_cps(main_freq) #$main_freq+(cent(25)*jitter:k(1, gkbeatf/8, gkbeatf))#\n#define cordelia_wooden3_q(main_freq) #$main_freq+jitter:k(1, gkbeatf/8, gkbeatf)#\n\n\topcode cordelia_wooden3, a, akk\n\tain, kfreq, kq xin\n\nif1\t\tinit 1000\nif2\t\tinit 3000\n\niq1\t\tinit 12\niq2\t\tinit 8\n\nilow\t\tinit 2\nihigh\t\tinit 15\nitime\t\tinit ksmps/sr\nif itime <= 0 then\n\titime = 1/2\nendif\nidbthresh\tinit 3 ; dB threshold\n\nkoct, kamp\tpitch ain, itime, ilow, ihigh, idbthresh\n\naexc1\t\tmode ain, $cordelia_wooden3_cps(if1), $cordelia_wooden3_q(iq1)\naexc2\t\tmode ain, $cordelia_wooden3_cps(if2), $cordelia_wooden3_q(iq2)\n\naexc\t\t= (aexc1+aexc2)/2\n\nkmain_freq\tportk limit(cpsoct(koct), 20, 20$k), itime\nkfreq1\t\tlimit kmain_freq*kfreq, 20, 20$k\nkfreq2\t\tlimit kmain_freq*kfreq*2, 20, 20$k\n\nares1\t\tmode aexc, $cordelia_wooden3_cps(kfreq1), $cordelia_wooden3_q(scale(kq, 50, 60))\nares2\t\tmode aexc, $cordelia_wooden3_cps(kfreq2), $cordelia_wooden3_q(scale(kq, 42, 53))\n\namode\t\t= (a(kamp)/8192)*(ares1+ares2)/4096\naout\t\t= amode\n\n\txout aout\n\tendop"
    },
    "wow": {
        "input": "kk",
        "core": "PARAM_1     init 1\nPARAM_2     init 1\n\nPARAM_OUT cordelia_wow PARAM_IN, PARAM_1, PARAM_2",
        "opcode": "opcode cordelia_wow, a, akk\n\tain, kfactor, kwet xin\n\nimax_del\tinit 3500\n\n; subtle wow/flutter LFO\nidepth1\t\tinit 3.5\nirate1 \t\tinit 1/10\namod1 \t\toscili idepth1+jitter(1, 1/8, 1/32), irate1\n\nidepth2\t\tinit 1.5\t\t\t\t\t\nirate2 \t\tinit 1/7\namod2 \t\toscili idepth2+jitter(.5, 1/8, 1/32), irate2\n\namod \t\t= amod1 + amod2\n\nawow \t\tvdelay ain*kwet, 15 + amod*a(kfactor)*10, imax_del\n\naout\t\t= ain*(1-kwet)+ awow\n\n\txout aout\n\tendop"
    },
    "wow2": {
        "input": "kk",
        "core": "PARAM_1     init 1\nPARAM_2     init 1\n\nPARAM_OUT cordelia_wow2 PARAM_IN, PARAM_1, PARAM_2",
        "opcode": "opcode cordelia_wow2, a, akk\n\tain, kfactor, kwet xin\n\nimax_del\tinit 15\n\n; subtle wow/flutter LFO\nidepth1\t\tinit 3.5\t\t\t\t\t\nirate1 \t\tinit 1/10\namod1 \t\toscili idepth1+jitter(1, 1/8, 1/32), irate1\n\nidepth2\t\tinit 1.5\t\t\t\t\t\nirate2 \t\tinit 1/7\namod2 \t\toscili idepth2+jitter(.5, 1/8, 1/32), irate2\n\namod \t\t= amod1 + amod2\n\nawow vdelay ain*kwet, .015 + amod*a(kfactor), imax_del\n\naout\t\t= ain*(1-kwet)+ awow\n\n\txout aout\n\tendop"
    },
    "zd": {
        "input": "kk",
        "core": "PARAM_1    init 500\nPARAM_2    init .5\n\nPARAM_OUT cordelia_zdf_ladder PARAM_IN, PARAM_1, PARAM_2",
        "opcode": "opcode cordelia_zdf_ladder, a, akk\n    ain, kfreq, kq xin\n\nkfreq_var   = (kfreq*11/10)-kfreq\naout        moogladder2 ain, kfreq+jitter(1, gkbeatf/8, gkbeatf)*kfreq_var, .5+kq*15\naout\t    balance2 aout, ain\n\n    xout aout\n    endop"
    }
}